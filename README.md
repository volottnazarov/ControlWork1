# ControlWork1        
# GeekBrains. Факультет Разработчик. Основной курс
*Студент Назаров Владимир*



## Итоговая контрольная работа по основному блоку


**Задание**

>1. Создать репозиторий на GitHub
>2. Нарисовать блок-схему алгоритма (можно обойтись блок-схемой основной содержательной части, если вы выделяете её в отдельный метод)
>3. Снабдить репозиторий оформленным текстовым описанием решения (файл README.md)
>4. Написать программу, решающую поставленную задачу
>5. Использовать контроль версий в работе над этим небольшим проектом (не должно быть так, что всё залито одним коммитом, как минимум этапы 2, 3, и 4 должны быть расположены в разных коммитах)

>Задача: Написать программу, которая из имеющегося массива строк формирует новый массив из строк, длина которых меньше, либо равна >3 символам. Первоначальный массив можно ввести с клавиатуры, либо задать на старте выполнения алгоритма. При решении не рекомендуется пользоваться коллекциями, лучше обойтись исключительно массивами.

>Примеры:
>>[“Hello”, “2”, “world”, “:-)”] → [“2”, “:-)”] 

>>[“1234”, “1567”, “-2”, “computer science”] → [“-2”]

>>[“Russia”, “Denmark”, “Kazan”] → []


## Решение

>>Для заполнения исходного массива строками с длинной их меньше или равными трем символам, необходимо выяснить его длинну.Узнав длинну массива мы тем самым исключим пустые позиции и оставим нужное количество позиций, что бы все значения, прошедшие отбор поместились в него. Для этого я создал метод **LengthArray**(Схема 1) ,  который на входе принимает заданный массив, создается переменная *count* , прогоняем массив циклом *for* внутри которого вложено условие *if* . В этом условии сравнивается длина строки каждого элемента массива с заданным значением **<=3**, при выполнении которого переменная *count* увеличивается на один. При завершении цикла, функция возвращает значение *count*, которую позже я буду использовать как значение длинны исходного массива.

>>Теперь, зная длинну будущего исходного массива мы его создаем: **result[]**

>>Далее мы создаем метод **SortArray**(Схема 2) , чем то похожий на метод **LengthArray**, в котором добавлен еще один массив *result*, и в сравнении *if* изменены действия, здесь переменная *count* является индексом исходного массива *result* . При выполнении условия значению *result[count]* присваивается значение заданного массива *ArrayOne[i]*.

>>**PrintArray**- метод печати (Схема 3). Здесь я делаю вывод на экран заданного массива с переходящей стрелкой в исходный массив, идентично примеру задачи. Прогоняю массив циклом *for*, вывожу в печать в кавычках через запятую значение *array[i]*, добавляю условие *if* где сравниваю значение *i* с длинной массива уменьшенной на *1* для того чтобы после последнего значения массива не ставилась запятая.

К решению прилагаю блок схемы.

# Блок схемы 
![Блок схемы](<Контр. Работа 1.png>)